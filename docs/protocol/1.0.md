# 通信 `v1.0`

### 1. 基础数据类型
数据包由这些数据类型组成。

| 类型名 | 字节数 | 描述 |
| --- | --- | --- |
| `Byte` | `1` | 字节 |
| `VarInt` | `[1..5]` | 可变长度的 32 位整型数 |
| `VarString` | `string.encode('utf-8').length + ` <br> `VarInt(string.encode('utf-8').length).length` | 字符串 |

#### 1.1. `Byte`
单个字节。

#### 1.2. `VarInt`
将 **32 位整型数**编码成**可变长度 32 位整型数**的方法：
1. 从右向左，每 7 位作为一组，将每一组放入一个新字节中，字节最高位目前不确定，可以被分成 5 组，使用 `g[0..4]` 表示这 5 组，其中 `g[0]` 为最右一组， `g[i][j]` 表示为第 `i` 组的第 `j` 个字节。
2. `i` 从 `0` 开始，对于 `g[i]`：
    + 若 `g[i+1..4]` 的低 7 位中有不为 `0` 的，则代表分组左侧还有数据，因此令 `g[i][7]` 为 `1` ，并让 `i` 自增一，进入下一轮；
    + 若 `i+1 > 4` 或者 `g[i+1..4]` 的低 7 位全为 `0` 或者，则代表左侧已没有数据，因此令 `g[i][7]` 为 `0` ，且放弃分组 `g[i+1..4]`。
3. 目前得到的 `i` 为最左分组的坐标。
4. `g[0..i]` 为最终字节数组。


> 需要注意，若原数据为负数，则按照该方法编码出来的字节长度始终为 5 ，因此知道原数据为负数的情况下，可以跳过字节长度的计算。

举例如下：

| 原数据 | 字节数组 |
| --- | --- |
| `0x00000000` | `[0x00]` |
| `0x00000002` | `[0x02]` |
| `0x0000007F` | `[0x7F]` |
| `0x00000081` | `[0x81, 0x01]` |
| `0x00013531` | `[0xB1, 0xEA, 0x04]` |
| `0x80000000` | `[0x80, 0x80, 0x80, 0x80, 0x08]` |
| `0xABCDABCD` | `[0xCD, 0xD7, 0xB6, 0xDE, 0x0A]` |


代码逻辑参考：
```java
public byte[] getVarIntBytes(int value) {
    byte[] bytes = new byte[5];
    int i = 0;

    while (true) {
        if ((value & ~0x7F) == 0) {
            bytes[i] = ((byte) value);
            return Arrays.copyOfRange(bytes, 0, i + 1);
        }

        bytes[i] = ((byte) ((value & 0x7F) | 0x80));
        value >>>= 7;
        i++;
    }
}
```

#### 1.3. `VarString`
将字符串编码成 `VarString` 的方法：
1. 将字符串 `s` 使用 `UTF-8` 编码为字节数组 `sb` 。
2. 使用 `VarInt` 编码字符串字节数组的长度 `sb.length` ，结果为 `vi` 。
3. 最终字节数组为 `vi + sb` 。

| 字符串 | 字节数组 |
| --- | --- |
| `lucky` | `[0x05, `<br>`0x6C, 0x75, 0x63, 0x6B, 0x79]` |
| `he` | `[0x02, `<br>`0x68, 0x65]` |

### 2. 数据包

数据包由以下结构组成：

| 数据名 | 类型 | 描述 |
| --- | --- | --- |
| `packetLength` | `VarInt` | 下面所有数据的总字节长度 |
| `packetType` | `Byte` | 数据包类型 |
| `dataCounts` | `VarInt` | 数据列表元素个数 |
| `data[]` | `Data` | 数据 |

其中 `Data` 为键值对形式，定义如下：

| 数据名 | 类型 | 描述 |
| --- | --- | --- |
| `dataKey` | `VarString` | 数据键 |
| `dataValue` | `VarString` | 数据值 |

### 3. 数据包类型

| 数值 | 描述 |
| --- | --- |
| `0x00` | 通信初始化 |
| `0x01` | 配置 |
| `0x02` | 监听数据上报 |
| `0x03` | 控制调用 |
| `0xFE` | 关闭连接 |
| `0xFF` | 紧急断开连接 |

### 4. 数据包举例
以发送下列数据为例，数据包类型为配置：
```json
{
    "data.a.b": "abc",
    "data.c.d": "def"
}
```

字节内容：
```
0x1C                             # packetLength VarInt
    0x01                         # packetType Byte
    0x02                         # dataCounts VarInt
        0x08                     # dataKey 1 VarString
            0x64 0x61 0x74 0x61
            0x2E 0x61 0x2E 0x62
        0x03                     # dataValue 1 VarString
            0x61 0x62 0x63
        0x08                     # dataKey 2 VarString
            0x64 0x61 0x74 0x61
            0x2E 0x63 0x2E 0x64
        0x03                     # dataValue 2 VarString
            0x64 0x65 0x66
```